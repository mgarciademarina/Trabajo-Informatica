int Tablero::jaque() {
	int a, b, i, j, jaque1 = 0, jaque2 = 0, comer1 = 0, comer2 = 0, proteger1 = 0, proteger2 = 0, mover1 = 0, mover2 = 0;
	Casilla rb, rn, EnemigoB, EnemigoN;
	for (i = 0; i < 8; i++) {
		for (j = 0; j < 8; j++) {
			if (tab[i][j].pieza == REY && tab[i][j].color == NEGRO) {
				rn = tab[i][j].casilla;
			}
			else if (tab[i][j].pieza == REY && tab[i][j].color == BLANCO) {
				rb = tab[i][j].casilla;
			}
		}
	}//para saber donde estÃ¡n los reyes
	for (i = 0; i < 8; i++) {
		for (j = 0; j < 8; j++) {
			if (tab[i][j].pieza != NO_PIEZA && tab[i][j].color == NEGRO) {
				if (validarMov(tab[i][j].casilla, rb)) {
					EnemigoN = tab[i][j].casilla;
					jaque1++;
				}
			}
			else if (tab[i][j].pieza != NO_PIEZA && tab[i][j].color == BLANCO) {
				if (validarMov(tab[i][j].casilla, rn)) {
					EnemigoB = tab[i][j].casilla;
					jaque2++;
				}
			}
		}
	}/para saber si hay jaque
	if (jaque2 > 0) {
		for (i = 0; i < 8; i++) {
			for (j = 0; j < 8; j++) {
				if (tab[i][j].pieza != NO_PIEZA && tab[i][j].color == NEGRO) {
					if (validarMov(tab[i][j].casilla, EnemigoB)){
						comer2++;
					}//para saber si una pieza amiga puede comer a la pieza que amenaza
					if (tab[i][j].casilla!=rn && Trayectoria(EnemigoB, rn, tab[i][j].casilla) == 2) {
						proteger2++;
					}//para saber si una pieza amiga puede bloquear la trayectoria de la pieza que amenaza
				}
				if (validarMov(rn, tab[i][j].casilla) && (Trayectoria(EnemigoB, tab[i][j].casilla, NULL) == 0)) {
					posibles = tab[i][j].casilla;
					mover2++;
					for (a = 0; a < 8; a++) {
						for (b = 0; b < 8; b++) {
							if (tab[a][b].color == BLANCO && tab[a][b].pieza != REY) {
								if (validarMov(tab[a][b].casilla, posibles)) {
									mover2--;
								}
							}
						}
					}//para saber si una pieza enemiga impide que el rey se ponga a salvo
				}//para saber si el rey se puede apartar de la trayectoria de la pieza que amenaza
			}
		}
	}
	if (jaque1 > 0) {
		for (i = 0; i < 8; i++) {
			for (j = 0; j < 8; j++) {
				if (tab[i][j].pieza != NO_PIEZA && tab[i][j].color == BLANCO) {
					if (validarMov(tab[i][j].casilla, EnemigoN)) {
						comer1++;
					}
					if (tab[i][j].casilla!=rb && Trayectoria(EnemigoN, rb, tab[i][j].casilla) == 2) {
						proteger1++;
					}
				}
				if (validarMov(rb, tab[i][j].casilla) && (Trayectoria(EnemigoN, tab[i][j].casilla, NULL) == 0)) {
					posibles = tab[i][j].casilla;
					mover1++;
					for (a = 0; a < 8; a++) {
						for (b = 0; b < 8; b++) {
							if (tab[a][b].color == NEGRO && tab[a][b].pieza != REY) {
								if (validarMov(tab[a][b].casilla, posibles)) {
									mover1--;
								}
							}
						}
					}
				}
			}
		}
	}
	cout << jaque1 << "/" << comer1 << "/" << mover1 << "/" << proteger1 <<  endl;
	cout << jaque2 << "/" << comer2 << "/" << mover2 << "/" << proteger2 <<  endl;
  //para comprobar como funciona
	if (jaque1 > 0) {
		if (comer1 == 0 && mover1 == 0 && (proteger1 == 0 || tab[EnemigoN.f][EnemigoN.c].pieza == REY || tab[EnemigoN.f][EnemigoN.c].pieza == CABALLO || tab[EnemigoN.f][EnemigoN.c].pieza == PEON)) {
			return 3;
		}//si se cumplen todos o no se cumple proteger (bloquear la trayectoria) pero la pieza no puede ser bloqueada, jaquemate
		else {
			return 1;
		}//si solo se cumple jaque, jaque 
	}
	if (jaque2 > 0) {
		if (comer2 == 0 && mover2 == 0 && (proteger2 == 0 || tab[EnemigoB.f][EnemigoB.c].pieza == REY || tab[EnemigoB.f][EnemigoB.c].pieza == CABALLO || tab[EnemigoB.f][EnemigoB.c].pieza == PEON)) {
			return 4;
		}
		else {
			return 2;
		}
	}
	else {
		return 0;
	}
}
int Tablero::Trayectoria(Casilla ori, Casilla des, Casilla prot) {
	int i = 0, j = 0;
	Casilla aux;
	aux = ori;
	if (tab[ori.f][ori.c].pieza == TORRE || tab[ori.f][ori.c].pieza == REINA) {
		if (ori.c - des.c == 0) {
			do {
				if (ori.f - des.f > 0) {
					aux.f--;
					if (validarMov(prot, aux)) {
						j++;
					}
				}
				else if (ori.f - des.f < 0) {
					aux.f++;
					if (validarMov(prot, aux)) {
						j++;
					}
				}
				if (aux.f == des.f) {
					i++;
				}
			} while ((aux.f != des.f));
		}
		else if (ori.f - des.f == 0) {
			do {
				if (ori.c - des.c > 0) {
					aux.c--;
					if (validarMov(prot, aux)) {
						j++;
					}
				}
				else if (ori.c - des.c < 0) {
					aux.c++;
					if (validarMov(prot, aux)) {
						j++;
					}
				}
				if (aux.c == des.c) {
					i++;
				}
			} while ((aux.c != des.c));
		}
	}
	if (tab[ori.f][ori.c].pieza == ALFIL || tab[ori.f][ori.c].pieza == REINA) {
		if (ori.f - des.f < 0) {
			do {
				if (ori.c - des.c > 0) {
					aux.c--;
					aux.f++;
					if (validarMov(prot, aux)) {
						j++;
					}
				}
				else if (ori.c - des.c < 0) {
					aux.c++;
					aux.f++;
					if (validarMov(prot, aux)) {
						j++;
					}
				}
				if (tab[aux.f][aux.c].casilla == des) {
					i++;
				}
			} while ((aux.c != des.c && aux.f != des.f));
		}
		else if (ori.f - des.f > 0) {
			do {
				if (ori.c - des.c > 0) {
					aux.c--;
					aux.f--;
					if (validarMov(prot, aux)) {
						j++;
					}
				}
				else if (ori.c - des.c < 0) {
					aux.c++;
					aux.f--;
					if (validarMov(prot, aux)) {
						j++;
					}
				}
				if (aux == des) {
					i++;
				}
			} while ((aux.c != des.c && aux.f != des.f));
		}
	}
	if (i > 0) {
		if (j > 0) {
			return 2;
		}
		else {
			return 1;
		}
	}
	else {
		return 0;
	}
}
